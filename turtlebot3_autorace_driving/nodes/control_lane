#!/usr/bin/env python
# -*- coding: utf-8 -*-

################################################################################
# Copyright 2018 ROBOTIS CO., LTD.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################

# Author: Leon Jung, Gilbert, Ashe Kim
 
import rospy
import tf
import numpy as np
from std_msgs.msg import Float64, Bool
from sensor_msgs.msg import LaserScan
from geometry_msgs.msg import Twist
from nav_msgs.msg import Odometry
import time
import math

class ControlLane():
    def __init__(self):
        self.sub_scan_obstacle = rospy.Subscriber('/scan', LaserScan, self.cbScanObstacle, queue_size=1)
        self.sub_lane = rospy.Subscriber('/control/lane', Float64, self.cbFollowLane, queue_size = 1)
        self.sub_max_vel = rospy.Subscriber('/control/max_vel', Bool, self.cbGetMaxVel, queue_size = 1)
        self.sub_is_reverse = rospy.Subscriber('/control/is_reverse', Bool, self.cbIsReverse, queue_size = 1)
        self.sub_is_stop = rospy.Subscriber('/control/is_stop', Bool, self.cbIsStop, queue_size = 1)
        self.sub_rotate_180 = rospy.Subscriber('/control/rotate_180', Bool, self.cbRotate180, queue_size = 1)
        self.sub_odom = rospy.Subscriber('/odom', Odometry, self.cbOdom, queue_size = 1)

        self.pub_cmd_vel = rospy.Publisher('/control/cmd_vel', Twist, queue_size = 1)
        self.pub_error = rospy.Publisher('/control/error', Float64, queue_size = 1)
        self.pub_cumul_square_error = rospy.Publisher('/control/cumul_square_error', Float64, queue_size = 1)
        self.pub_mse_error = rospy.Publisher('/control/mse_error', Float64, queue_size = 1)

        self.MAX_VEL = 0.18
        self.OBSTACLE_DISTANCE_THRESHOLD = 0.35
        self.OBSTACLE_AVOID_DISTANCE = 0.27 * (2**0.4)
        # in radian
        self.OBSTACLE_AVOID_ROTATE_ANGLE = np.pi / 3.5
        # zero degree +- OBSTACLE_AVOID_SCAN_RANCE
        self.OBSTACLE_AVOID_SCAN_RANCE = 15
        # 연속으로 n프레임 이상 장애물 감지 시 회피 로직 시갖
        self.OBSTACLE_DETECTED_FRAME_THRESHOLD = 10

        self.cumul_error = 0
        self.cumul_sqaure_error = 0
        self.spin_cnt = 0
        self.lastError = 0

        self.is_obstacle_detected = False
        self.avoiding_obstacle = False
        self.avoid_step = -1
        self.is_reverse = False
        self.is_reverse_switched = False
        self.is_stop = False
        self.is_rotating = False
        self.is_straight_moving = False
        self.desired_dist = -1
        self.time = 0
        self.obstacle_detected_frame = 0\
        

        #moving internal valiables
        self.theta = 0.0
        self.current_theta = 0.0
        self.last_current_theta = 0.0
        self.lastError = 0.0

        rospy.on_shutdown(self.fnShutDown)

    def cbGetMaxVel(self, max_vel_msg):
        self.MAX_VEL = max_vel_msg.data

    def cbIsReverse(self, is_reverse_msg):
        if self.is_reverse != is_reverse_msg.data:
            self.is_reverse_switched = True
            # self.reverse_degree_sum += 180
        self.is_reverse = is_reverse_msg.data
    
    def cbIsStop(self, is_stop_msg):
        self.is_stop = is_stop_msg.data

    def cbRotate180(self, msg):
        if not self.is_rotating and msg.data == True:
            self.is_rotating = msg.data
            self.desired_theta = self.current_theta + np.pi
            self.lastError = 0

    def start_rotate(self, theta):
        self.is_rotating = True
        self.desired_theta = self.current_theta + theta
        self.lastError = 0

    def rotate(self):
        error = self.rotate_control()
        rospy.loginfo("error : %f (%f deg)", error, error * 180 / np.pi)

        if abs(error) < 0.02:
            self.is_rotating = False
            twist = Twist()
            twist.linear.x = 0 #0
            twist.linear.y = 0
            twist.linear.z = 0
            twist.angular.x = 0
            twist.angular.y = 0
            twist.angular.z = 0
            self.pub_cmd_vel.publish(twist)
            self.lastError = 0

    def rotate_control(self):
        err_theta = self.current_theta - self.desired_theta
        
        # rospy.loginfo("err_theta  desired_theta  current_theta : %f  %f  %f", err_theta, self.desired_theta, self.current_theta)
        Kp = 0.64
        Kd = 0.04

        angular_z = Kp * err_theta + Kd * (err_theta - self.lastError)
        self.lastError = err_theta

        twist = Twist()
        twist.linear.x = 0 #0
        twist.linear.y = 0
        twist.linear.z = 0
        twist.angular.x = 0
        twist.angular.y = 0
        twist.angular.z = -(angular_z * 2)
        self.pub_cmd_vel.publish(twist)

        # rospy.loginfo("angular_z : %f", angular_z)

        return err_theta

    def start_straight(self, dist):
        self.is_straight_moving = True
        self.pose_start = self.pose
        self.desired_dist = dist
        self.lastError = 0
    
    def straight(self):
        error = self.straight_control()
        rospy.loginfo("error : %f", error)

        if abs(error) < 0.02:
            self.is_straight_moving = False
            twist = Twist()
            twist.linear.x = 0 #0
            twist.linear.y = 0
            twist.linear.z = 0
            twist.angular.x = 0
            twist.angular.y = 0
            twist.angular.z = 0
            self.pub_cmd_vel.publish(twist)
            self.lastError = 0

    def straight_control(self):
        dist = math.sqrt((self.pose.position.x - self.pose_start.position.x)**2 + (self.pose.position.y - self.pose_start.position.y)**2)
        err_dist = self.desired_dist - dist
        # TODO : set proper Kp and Kd with tuning
        Kp = 0.64
        Kd = 0.04

        angular_z = Kp * err_dist + Kd * (err_dist - self.lastError)
        self.lastError = err_dist

        twist = Twist()
        twist.linear.x = min(self.MAX_VEL, err_dist)
        twist.linear.y = 0
        twist.linear.z = 0
        twist.angular.x = 0
        twist.angular.y = 0
        twist.angular.z = 0
        self.pub_cmd_vel.publish(twist)

        return err_dist
    
    def avoid_obstacle(self):
        if self.avoid_step == 0:
            if self.is_rotating:
                self.rotate()
            else:
                rospy.loginfo("Move to Step 1")
                self.avoid_step = 1
                self.start_straight(self.OBSTACLE_AVOID_DISTANCE)
        elif self.avoid_step == 1:
            if self.is_straight_moving:
                self.straight()
            else:
                rospy.loginfo("Move to Step 2")
                self.avoid_step = 2
                self.start_rotate(-self.OBSTACLE_AVOID_ROTATE_ANGLE)
        elif self.avoid_step == 2:
            if self.is_rotating:
                self.rotate()
            else:
                self.avoid_step = -1
                self.avoiding_obstacle = False
                self.cumul_error = 0
                self.OBSTACLE_AVOID_ROTATE_ANGLE *= -1


    def cbFollowLane(self, desired_center):
        if self.avoiding_obstacle:
            self.avoid_obstacle()
            return
        
        self.spin_cnt += 1
        center = desired_center.data

        # print(center)
        
        error = center - 500
        self.cumul_error += error
        self.cumul_sqaure_error += error ** 2

        # stop the robot if obstacle is detected
        # if self.is_obstacle_detected or self.is_stop:
        #     twist = Twist()
        #     twist.linear.x = 0
        #     twist.linear.y = 0
        #     twist.linear.z = 0
        #     twist.angular.x = 0
        #     twist.angular.y = 0
        #     twist.angular.z = 0
        #     self.pub_cmd_vel.publish(twist)
        #     self.pub_error.publish(error)
        #     self.pub_cumul_square_error.publish(self.cumul_sqaure_error)
        #     self.pub_mse_error.publish(np.sqrt(self.cumul_sqaure_error / self.spin_cnt))
        #     return

        # Original Kp : 0.0025
        Kp = 0.0055
        # Original Kd : 0.007
        Kd = 0.01
        # Ki was added later
        # TODO : set proper Ki with tuning
        Ki = 0.0015

        angular_z = Kp * error + Kd * (error - self.lastError) + Ki * self.cumul_error
        self.lastError = error
        
        twist = Twist()
        # twist.linear.x = 0.05        
        twist.linear.x = min(self.MAX_VEL * ((1 - abs(error) / 500) ** 2.2), 0.05)
        twist.linear.y = 0
        twist.linear.z = 0
        twist.angular.x = 0
        twist.angular.y = 0
        twist.angular.z = -max(angular_z, -2.0) if angular_z < 0 else -min(angular_z, 2.0)

        # Move the robot
        self.pub_cmd_vel.publish(twist)

        # For logging
        self.pub_error.publish(error)
        self.pub_cumul_square_error.publish(self.cumul_sqaure_error)
        self.pub_mse_error.publish(np.sqrt(self.cumul_sqaure_error / self.spin_cnt))

    def cbScanObstacle(self, scan):
        scan_start = 0 - self.OBSTACLE_AVOID_SCAN_RANCE
        scan_end = 0 + self.OBSTACLE_AVOID_SCAN_RANCE
        is_obstacle_detected = False
        min_distance = 1000.

        for i in range(scan_start, scan_end + 1):
            min_distance = min(min_distance, scan.ranges[i])
        rospy.loginfo("min_distance : %f", min_distance)

        if min_distance < self.OBSTACLE_DISTANCE_THRESHOLD and not self.avoiding_obstacle:
            self.obstacle_detected_frame += 1
        else :
            self.obstacle_detected_frame = 0
        if self.obstacle_detected_frame > self.OBSTACLE_DETECTED_FRAME_THRESHOLD:
            rospy.loginfo("Obstacle detected")
            is_obstacle_detected = True
            self.avoiding_obstacle = True
            self.avoid_step = 0
            self.start_rotate(self.OBSTACLE_AVOID_ROTATE_ANGLE)
            self.is_obstacle_detected = is_obstacle_detected
            return

        self.is_obstacle_detected = is_obstacle_detected
        
    def euler_from_quaternion(self, quaternion):
        theta = tf.transformations.euler_from_quaternion(quaternion)[2]
        return theta

    def fnShutDown(self):
        rospy.loginfo("Shutting down. cmd_vel will be 0")

        twist = Twist()
        twist.linear.x = 0
        twist.linear.y = 0
        twist.linear.z = 0
        twist.angular.x = 0
        twist.angular.y = 0
        twist.angular.z = 0
        self.pub_cmd_vel.publish(twist) 

    def cbOdom(self, odom_msg):
        self.pose = odom_msg.pose.pose
        quaternion = (odom_msg.pose.pose.orientation.x, odom_msg.pose.pose.orientation.y, odom_msg.pose.pose.orientation.z, odom_msg.pose.pose.orientation.w)
        self.current_theta = self.euler_from_quaternion(quaternion)

        if (self.current_theta - self.last_current_theta) < -math.pi:
            self.current_theta = 2. * math.pi + self.current_theta
            self.last_current_theta = math.pi
        elif (self.current_theta - self.last_current_theta) > math.pi:
            self.current_theta = -2. * math.pi + self.current_theta
            self.last_current_theta = -math.pi
        else:
            self.last_current_theta = self.current_theta

    def main(self):
        rospy.spin()

if __name__ == '__main__':
    rospy.init_node('control_lane')
    node = ControlLane()
    node.main()
